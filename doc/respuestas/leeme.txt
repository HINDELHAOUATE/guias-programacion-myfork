TEMA 1. Clases y objetos
1. Â¿CuÃ¡les son las cuatro caracterÃ­sticas bÃ¡sicas de la programaciÃ³n orientada a objetos? Describe brevemente cada una
Respuesta

Los 4 Pilares de la ProgramaciÃ³n Orientada a Objetos

1. AbstracciÃ³n
ğŸ”¹ DefiniciÃ³n: Representar en una clase solo los atributos y comportamientos esenciales de un objeto real, ocultando los detalles innecesarios.

ğŸ’¡ Ejemplo:
Al modelar un Coche, nos quedamos con marca, modelo y arrancar(), pero ignoramos detalles como el material de cada tornillo.

public class Coche {
    private String marca;      // Esencial
    private String modelo;     // Esencial
    
    public void arrancar() {   // Comportamiento relevante
        System.out.println("Â¡Brum brum!");
    }
}

âš ï¸ Clave: EnfÃ³cate en el "quÃ© hace" y no en el "cÃ³mo lo hace internamente".

2. Encapsulamiento
ğŸ”¹ DefiniciÃ³n: Ocultar el estado interno de un objeto y permitir acceso controlado mediante mÃ©todos pÃºblicos (getters/setters).

ğŸ’¡ Ejemplo:

public class Persona {
    private int edad; // ğŸ”’ Atributo privado
    
    // Acceso controlado
    public int getEdad() {
        return edad;
    }
    
    public void setEdad(int nuevaEdad) {
        if (nuevaEdad >= 0) { // âœ… ValidaciÃ³n
            this.edad = nuevaEdad;
        }
    }
}

âš ï¸ Beneficio: Protege la integridad de los datos y evita modificaciones indebidas.

3. Herencia
ğŸ”¹ DefiniciÃ³n: Mecanismo que permite que una clase (hija/subclase) herede atributos y mÃ©todos de otra clase (padre/superclase). Promueve la reutilizaciÃ³n de cÃ³digo.

ğŸ’¡ Ejemplo:

class Animal {
    void comer() {
        System.out.println("Comiendo...");
    }
}

class Perro extends Animal { // ğŸ• Hereda de Animal
    void ladrar() {
        System.out.println("Â¡Guau!");
    }
}

âš ï¸ RelaciÃ³n: Se modela con "es un" â†’ Perro es un Animal.

4. Polimorfismo
ğŸ”¹ DefiniciÃ³n: La capacidad de un objeto de tomar diferentes formas. En Java se manifiesta principalmente mediante:
Sobrecarga (overloading): Mismo nombre, distinta firma.
Sobreescritura (overriding): Redefinir un mÃ©todo en una subclase.

ğŸ’¡ Ejemplo (sobreescritura):

class Animal {
    void hacerSonido() {
        System.out.println("Sonido genÃ©rico");
    }
}

class Gato extends Animal {
    @Override
    void hacerSonido() { // ğŸ± Comportamiento especÃ­fico
        System.out.println("Â¡Miau!");
    }
}

// Uso
Animal miMascota = new Gato();
miMascota.hacerSonido(); // Salida: Â¡Miau!

âš ï¸ Clave: El tipo de referencia (Animal) y el objeto real (Gato) pueden ser distintos â†’ comportamiento dinÃ¡mico en tiempo de ejecuciÃ³n.

2. Cita cuatro lenguajes populares que permitan la programaciÃ³n orientada a objetos
Respuesta

Cuatro lenguajes populares que permiten programaciÃ³n orientada a objetos:

Java: 
Lenguaje estÃ¡tico y compilado que sigue el paradigma POO de forma estricta. Casi todo son objetos y se ejecuta en la MÃ¡quina Virtual de Java (JVM). Muy utilizado en desarrollo empresarial y Android.

C++: 
Lenguaje multiparadigma que extiende C con caracterÃ­sticas orientadas a objetos (clases, herencia, polimorfismo). No obliga a usar POO, pero lo soporta completamente. Empleado en sistemas, videojuegos y aplicaciones de alto rendimiento.

Python: 
Lenguaje dinÃ¡mico e interpretado donde todo es un objeto. Soporta POO pero tambiÃ©n permite programaciÃ³n procedural o funcional. Muy popular en ciencia de datos, inteligencia artificial y scripting.

C#: 
Lenguaje desarrollado por Microsoft con sintaxis similar a Java. Orientado a objetos por diseÃ±o y ejecutado sobre la plataforma .NET. Ampliamente usado en aplicaciones Windows, desarrollo web con ASP.NET y videojuegos con Unity.

3. Los paradigmas anteriores a la POO, Â¿QuÃ© es la programaciÃ³n estructurada? y, todavÃ­a mejor, Â¿QuÃ© es la programaciÃ³n modular?
Respuesta

ProgramaciÃ³n Estructurada

Es un paradigma surgido en los aÃ±os 60-70 (con Edsger Dijkstra como figura clave) que propone organizar el cÃ³digo mediante tres estructuras de control bien definidas:

Secuencia: ejecuciÃ³n lineal de instrucciones.
SelecciÃ³n: decisiones mediante if, switch, etc.
IteraciÃ³n: bucles mediante for, while, etc.

ğŸ”¹ Objetivo: 
Eliminar el uso descontrolado de la instrucciÃ³n goto para evitar el "cÃ³digo espagueti" y mejorar la legibilidad, mantenibilidad y razonamiento lÃ³gico del programa.

ğŸ”¹ Principio clave: 
Un programa debe tener un Ãºnico punto de entrada y un Ãºnico punto de salida.

ProgramaciÃ³n Modular
Es una evoluciÃ³n de la programaciÃ³n estructurada que propone dividir un programa grande en mÃ³dulos independientes y cohesivos.

ğŸ”¹ DefiniciÃ³n: 
Un mÃ³dulo es una unidad de cÃ³digo con una funcionalidad especÃ­fica, con interfaz clara (entrada/salida) y ocultaciÃ³n de su implementaciÃ³n interna.

ğŸ”¹ Objetivos:
ReutilizaciÃ³n: Un mÃ³dulo se puede usar en distintos programas.
Mantenibilidad: Corregir o mejorar un mÃ³dulo no afecta al resto.
Desarrollo en equipo: Distintos programadores pueden trabajar en mÃ³dulos diferentes simultÃ¡neamente.
AbstracciÃ³n: El usuario del mÃ³dulo solo necesita conocer quÃ© hace, no cÃ³mo lo hace.

ğŸ”¹ RelaciÃ³n con POO: 
La programaciÃ³n modular es un precursor directo del encapsulamiento en POO. Las clases en POO son, en esencia, mÃ³dulos avanzados que agrupan datos y comportamiento.

4. Â¿QuÃ© tres elementos definen a un objeto en programaciÃ³n orientada a objetos?
Respuesta

Todo objeto en programaciÃ³n orientada a objetos se define por tres elementos fundamentales:
>Estado
Conjunto de valores que describen las caracterÃ­sticas del objeto en un momento dado. Se almacena en los atributos (tambiÃ©n llamados campos o propiedades) de la clase. El estado puede cambiar a lo largo de la vida del objeto mediante operaciones.

>Comportamiento
Conjunto de acciones u operaciones que el objeto puede realizar o que se pueden realizar sobre Ã©l. Se define mediante los mÃ©todos de la clase. El comportamiento determina cÃ³mo responde el objeto a los mensajes que recibe y cÃ³mo modifica su propio estado.

>Identidad
CaracterÃ­stica que distingue a un objeto de cualquier otro, incluso si comparten el mismo estado y comportamiento. Cada objeto tiene una identidad Ãºnica que lo hace reconocible e individual. En Java, esta identidad estÃ¡ asociada a la referencia del objeto en memoria (aunque el programador no accede directamente a la direcciÃ³n de memoria).

5. Â¿QuÃ© es una clase? Â¿Es lo mismo que un objeto? Â¿QuÃ© es una instancia? Â¿Todos los lenguajes orientados a objetos manejan el concepto de clase?
Respuesta

Â¿QuÃ© es una clase?

Una clase es una plantilla o modelo abstracto que define:
Los atributos (caracterÃ­sticas/estado) que tendrÃ¡n los objetos.
Los mÃ©todos (comportamiento/acciones) que podrÃ¡n realizar los objetos.
Es una descripciÃ³n general, no un elemento concreto del programa.

Â¿Es lo mismo una clase que un objeto?

No. Son conceptos distintos:
La clase es la plantilla o molde (definiciÃ³n abstracta).
El objeto es un elemento concreto creado a partir de esa plantilla, con valores reales en sus atributos y capacidad para ejecutar sus mÃ©todos.
AnalogÃ­a:
La clase es como los planos de una casa.
El objeto es la casa construida a partir de esos planos.

Â¿QuÃ© es una instancia?

Una instancia es el resultado de crear un objeto a partir de una clase. El proceso se llama instanciaciÃ³n.
En Java se usa el operador new:

// Clase (plantilla)
class Coche {
    String marca;
    int velocidad;
    
    void acelerar() {
        velocidad += 10;
    }
}
// InstanciaciÃ³n: crear un objeto/instancia de la clase Coche
Coche miCoche = new Coche();  // miCoche es una instancia
miCoche.marca = "Toyota";
miCoche.acelerar();

Cada instancia tiene su propio estado independiente del resto de instancias.

Â¿Todos los lenguajes orientados a objetos manejan el concepto de clase?

No. Existen dos grandes enfoques:
Lenguajes basados en clases (class-based):
Usan clases como plantillas para crear objetos.
Ejemplos: Java, C++, C#, Python, Ruby.

Lenguajes basados en prototipos (prototype-based):
No existen clases. Los objetos se crean a partir de otros objetos existentes (prototipos), heredando directamente sus propiedades.
Ejemplo principal: JavaScript.
En JavaScript:

// No hay clase, se usa un objeto prototipo
const cochePrototipo = {
    marca: "",
    acelerar() { console.log("Acelerando"); }
};

// Crear un nuevo objeto basado en el prototipo
const miCoche = Object.create(cochePrototipo);
miCoche.marca = "Toyota";

6. Â¿DÃ³nde se almacenan en memoria los objetos? Â¿Es igual en todos los lenguajes? Â¿QuÃ© es la recolecciÃ³n de basura?
Respuesta

Â¿DÃ³nde se almacenan los objetos en memoria?

En lenguajes como Java, los objetos se almacenan en el heap (montÃ­culo), una zona de memoria dinÃ¡mica gestionada por la mÃ¡quina virtual.
Heap: 
Almacena los objetos creados con new. Es compartido por todo el programa y tiene mayor tamaÃ±o pero acceso mÃ¡s lento.
Stack (pila): Almacena las referencias a los objetos (variables que apuntan al heap) y los tipos primitivos locales. Es rÃ¡pido pero limitado en tamaÃ±o y duraciÃ³n (vida ligada al mÃ©todo).
java

public class Ejemplo {
    public void metodo() {
        int numero = 5;              // 'numero' â†’ stack (primitivo)
        Persona p = new Persona();   // 'p' â†’ stack (referencia)
                                     // new Persona() â†’ heap (objeto real)
    }
}

Â¿Es igual en todos los lenguajes?

No. La gestiÃ³n de memoria varÃ­a segÃºn el lenguaje:
Java, C#, Python, Ruby: Los objetos siempre van al heap. La memoria se gestiona automÃ¡ticamente mediante recolecciÃ³n de basura.
C++: El programador decide:
Persona p; â†’ objeto en stack (destruido al salir del Ã¡mbito).
Persona* p = new Persona(); â†’ objeto en heap (destrucciÃ³n manual con delete).
JavaScript: Los objetos se almacenan en el heap, pero el programador no tiene control directo sobre la memoria.

Â¿QuÃ© es la recolecciÃ³n de basura?

La recolecciÃ³n de basura (garbage collection, GC) es un mecanismo automÃ¡tico que libera la memoria ocupada por objetos que ya no son accesibles por el programa (objetos "huÃ©rfanos").
ğŸ”¹ CÃ³mo funciona (simplificado):
El recolector identifica objetos del heap a los que ninguna referencia activa apunta y los elimina para liberar memoria.
ğŸ”¹ Ventaja: 
Evita fugas de memoria y errores comunes de gestiÃ³n manual (dangling pointers, double free).
ğŸ”¹ Desventaja: 
Introduce pausas impredecibles (stop-the-world) y consume recursos de CPU.
ğŸ”¹ En Java:
La JVM ejecuta el GC de forma automÃ¡tica en segundo plano. No se puede forzar su ejecuciÃ³n, aunque se puede sugerir con System.gc() (no garantiza ejecuciÃ³n inmediata).
>>
Persona p = new Persona();
p = null;  // El objeto original ya no es accesible â†’ candidato a GC

ğŸ’¡ Nota clave

Heap â†’ objetos (vida dinÃ¡mica, gestiÃ³n automÃ¡tica o manual).
Stack â†’ referencias y primitivos locales (vida ligada al mÃ©todo).
GC â†’ mecanismo automÃ¡tico de limpieza de memoria (Java, C#, Python...).
C/C++ â†’ sin GC; el programador gestiona manualmente la memoria del heap.

7. Â¿QuÃ© es un mÃ©todo? Â¿QuÃ© es la sobrecarga de mÃ©todos?
Respuesta

Â¿QuÃ© es un mÃ©todo?

Un mÃ©todo es un bloque de cÃ³digo que define un comportamiento o una operaciÃ³n que puede realizar un objeto (o una clase). Agrupa un conjunto de instrucciones bajo un nombre para poder reutilizarlas.
ğŸ”¹ Elementos de un mÃ©todo en Java:
Modificador de acceso (public, private, protected, por defecto)
Tipo de retorno (void si no devuelve nada, o un tipo de dato)
Nombre del mÃ©todo
Lista de parÃ¡metros (entre parÃ©ntesis, puede estar vacÃ­a)
Cuerpo del mÃ©todo (instrucciones entre llaves {})

// Ejemplo de mÃ©todo
public class Calculadora {
    // MÃ©todo que devuelve un valor (int)
    public int sumar(int a, int b) {
        return a + b;
    }
    
    // MÃ©todo void (no devuelve nada)
    public void mostrarMensaje(String mensaje) {
        System.out.println(mensaje);
    }
}
âš ï¸ Nota: Los mÃ©todos definen el comportamiento de los objetos. Sin mÃ©todos, un objeto solo tendrÃ­a estado (datos) pero no podrÃ­a hacer nada.

Â¿QuÃ© es la sobrecarga de mÃ©todos?

La sobrecarga de mÃ©todos (method overloading) consiste en definir varios mÃ©todos con el mismo nombre pero con distinta lista de parÃ¡metros (en tipo, nÃºmero u orden) dentro de la misma clase.
ğŸ”¹ Reglas clave:
âœ… Diferente nÃºmero de parÃ¡metros.
âœ… Diferente tipo de parÃ¡metros.
âœ… Diferente orden de tipos de parÃ¡metros.
âŒ No basta con cambiar solo el tipo de retorno â†’ error de compilaciÃ³n.

public class Calculadora {
    // Sobrecarga 1: dos enteros
    public int sumar(int a, int b) {
        return a + b;
    }
    
    // Sobrecarga 2: tres enteros
    public int sumar(int a, int b, int c) {
        return a + b + c;
    }
    
    // Sobrecarga 3: dos doubles
    public double sumar(double a, double b) {
        return a + b;
    }
    
    // Sobrecarga 4: int y double (orden importa)
    public double sumar(int a, double b) {
        return a + b;
    }
    
    // Sobrecarga 5: double e int (distinto de la anterior por orden)
    public double sumar(double a, int b) {
        return a + b;
    }
}

ğŸ”¹ Â¿CÃ³mo decide Java quÃ© mÃ©todo usar?
El compilador elige el mÃ©todo adecuado en tiempo de compilaciÃ³n segÃºn los tipos y nÃºmero de argumentos pasados al invocar el mÃ©todo (resoluciÃ³n estÃ¡tica).

Calculadora calc = new Calculadora();
calc.sumar(2, 3);        // Llama a sumar(int, int)
calc.sumar(2, 3, 4);     // Llama a sumar(int, int, int)
calc.sumar(2.5, 3.1);    // Llama a sumar(double, double)

âš ï¸ No confundir con sobreescritura (overriding):
Sobrecarga: mismo nombre, distinta firma â†’ dentro de la misma clase (o clase hija sin @Override).
Sobreescritura: mismo nombre y misma firma â†’ en una clase hija que redefine un mÃ©todo heredado (usa @Override).

8. Ejemplo mÃ­nimo de clase en Java, que se llame Punto, con dos atributos, x e y, con un mÃ©todo que se llame calculaDistanciaAOrigen, que calcule la distancia a la posiciÃ³n 0,0. Por sencillez, los atributos deben tener visibilidad por defecto. Crea ademÃ¡s un ejemplo de uso con una instancia y uso del mÃ©todo
Respuesta

Ejemplo mÃ­nimo de clase en Java

// Clase Punto
class Punto {
    // Atributos con visibilidad por defecto (package-private)
    double x;
    double y;
    
    // Constructor para inicializar los atributos
    Punto(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    // MÃ©todo que calcula la distancia al origen (0,0)
    double calculaDistanciaAOrigen() {
        return Math.sqrt(x * x + y * y);
    }
}

// Clase de prueba con mÃ©todo main
public class PruebaPunto {
    public static void main(String[] args) {
        // Crear una instancia de Punto
        Punto p = new Punto(3.0, 4.0);
        
        // Usar el mÃ©todo
        double distancia = p.calculaDistanciaAOrigen();
        
        // Mostrar resultado
        System.out.println("Punto: (" + p.x + ", " + p.y + ")");
        System.out.println("Distancia al origen: " + distancia);
        // Salida esperada: Distancia al origen: 5.0
    }
}

ğŸ’¡ Notas clave
Visibilidad por defecto: 
Al no usar public, private ni protected, los atributos x e y son accesibles desde cualquier clase del mismo paquete.
FÃ³rmula usada: 
Distancia = âˆš(xÂ² + yÂ²) â†’ implementada con Math.sqrt().
Constructor: 
Necesario para inicializar los atributos al crear la instancia (new Punto(3.0, 4.0)).
EjecuciÃ³n: 
Guarda el cÃ³digo en un archivo PruebaPunto.java y compila/ejecuta con:
javac PruebaPunto.java
java PruebaPunto

9. Â¿CuÃ¡l es el punto de entrada en un programa en Java? Â¿QuÃ© es static y para quÃ© vale? Â¿SÃ³lo se emplea para ese mÃ©todo main? Â¿Para quÃ© se combina con final?
Respuesta

Punto de entrada en Java
El punto de entrada de todo programa Java es el mÃ©todo main con esta firma exacta:

public static void main(String[] args) {
    // CÃ³digo del programa
}

ğŸ”¹ Requisitos obligatorios:
Debe ser public (accesible desde la JVM).
Debe ser static (explicado a continuaciÃ³n).
Debe devolver void.
Debe llamarse exactamente main.
Debe recibir un array de String como parÃ¡metro (String[] args o String... args).

Sin este mÃ©todo, la JVM no puede iniciar la ejecuciÃ³n del programa (a excepciÃ³n de entornos especiales como mÃ³dulos Java 9+ con module-info.java).

Â¿QuÃ© es static y para quÃ© sirve?

static es un modificador que indica que un miembro (atributo, mÃ©todo, bloque o clase anidada) pertenece a la clase, no a las instancias de la clase.
ğŸ”¹ Diferencias clave:

class Ejemplo {
    // Atributo de instancia: cada objeto tiene su propia copia
    int contador;
    
    // Atributo estÃ¡tico: compartido por TODAS las instancias
    static int contadorGlobal;
    
    // MÃ©todo de instancia: necesita un objeto para invocarse
    void metodoInstancia() {
        contador++;          // Accede a atributo de instancia
        contadorGlobal++;    // TambiÃ©n puede acceder a estÃ¡ticos
    }
    
    // MÃ©todo estÃ¡tico: se invoca SIN necesidad de crear un objeto
    static void metodoEstatico() {
        contadorGlobal++;    // âœ… Puede acceder a estÃ¡ticos
        // contador++;       // âŒ ERROR: no puede acceder a no-estÃ¡ticos
    }
}

ğŸ”¹ Uso del mÃ©todo main:
Debe ser static porque la JVM lo invoca antes de que exista cualquier objeto de la clase. No hay instancia disponible al inicio del programa.

// InvocaciÃ³n por la JVM (sin crear objeto):
MiClase.main(args);

Â¿SÃ³lo se usa static para el mÃ©todo main?

No. static se usa en mÃºltiples contextos:
MÃ©todos de utilidad:
Clases como Math o Arrays contienen solo mÃ©todos estÃ¡ticos porque no necesitan estado:


Math.sqrt(16);      // No se crea un objeto Math
Arrays.sort(miArray);

Constantes de clase:
Atributos "static final" que representan valores fijos compartidos:

public static final double PI = 3.14159;

Contadores globales:
Para llevar un conteo compartido entre todas las instancias:

private static int numeroTotalObjetos = 0;

Bloques estÃ¡ticos:
InicializaciÃ³n de recursos al cargar la clase:

static {
    // CÃ³digo ejecutado una sola vez al cargar la clase
    System.out.println("Clase cargada");
}

Clases anidadas estÃ¡ticas:
Clases internas que no dependen de la instancia externa.

CombinaciÃ³n: static final
Esta combinaciÃ³n se usa principalmente para definir constantes de clase:

static: el valor es compartido por todas las instancias (pertenece a la clase).
final: el valor no puede modificarse despuÃ©s de su inicializaciÃ³n.

public class Configuracion {
    // Constante de clase: accesible sin instanciar y no modificable
    public static final int PUERTO_SERVIDOR = 8080;
    public static final String NOMBRE_APP = "MiAplicacion";
}

ğŸ”¹ Convenciones:
Los nombres de constantes se escriben en MAYÃšSCULAS con guiones bajos.
Se inicializan en la declaraciÃ³n o en un bloque estÃ¡tico.

public static final double IVA;
static {
    IVA = 0.21; // InicializaciÃ³n en bloque estÃ¡tico
}

âš ï¸ Importante:
"static" â‰  "final": uno indica pertenencia a la clase, el otro inmutabilidad.
Pueden usarse por separado:
"static" sin "final": variable de clase modificable.
"final" sin "static": atributo de instancia inmutable (cada objeto tiene su propia copia constante).

ğŸ’¡ Resumen clave
Punto de entrada: 
public static void main(String[] args)
static: 
Miembro de la clase, no de la instancia. Accesible sin crear objetos.
Usos frecuentes: 
main, mÃ©todos de utilidad, constantes, contadores globales.
static final: 
Define constantes de clase inmutables y compartidas.

10. Intenta ejecutar un poco de Java de forma bÃ¡sica, con los comandos javac y java. Â¿CÃ³mo podemos compilar el programa y ejecutarlo desde linea de comandos? Â¿Java es compilado? Â¿QuÃ© es la mÃ¡quina virtual? Â¿QuÃ© es el byte-code y los ficheros .class?
Respuesta

Compilar y ejecutar desde lÃ­nea de comandos

Paso 1: Escribir el cÃ³digo fuente
Crear un archivo con extensiÃ³n .java. El nombre del archivo debe coincidir con el nombre de la clase public:

// HolaMundo.java
public class HolaMundo {
    public static void main(String[] args) {
        System.out.println("Â¡Hola, mundo!");
    }
} 

Paso 2: Compilar con javac

javac HolaMundo.java

>Genera un archivo HolaMundo.class en el mismo directorio.
>Si hay errores de sintaxis, el compilador los muestra y no genera el .class.

Paso 3: Ejecutar con java

java HolaMundo

âš ï¸ Importante: 
Se indica el nombre de la clase, sin la extensiÃ³n ".class".
La JVM carga el bytecode y ejecuta el mÃ©todo "main".

Â¿Java es compilado o interpretado?

Java es compilado a bytecode, no a cÃ³digo mÃ¡quina nativo. El proceso tiene dos fases:
1. CompilaciÃ³n (javac):
El cÃ³digo fuente (.java) â†’ bytecode (.class).
2. EjecuciÃ³n (java):
La JVM interpreta (o compila JIT) el bytecode â†’ cÃ³digo mÃ¡quina nativo en tiempo de ejecuciÃ³n.

âœ… Ventaja: "Escribe una vez, ejecuta en cualquier sitio" (Write Once, Run Anywhere).

Â¿QuÃ© es la MÃ¡quina Virtual de Java (JVM)?

La JVM (Java Virtual Machine) es un entorno de ejecuciÃ³n que:
Carga los ficheros .class (bytecode).
Verifica su integridad y seguridad.
Ejecuta el bytecode, bien interpretÃ¡ndolo o compilÃ¡ndolo a cÃ³digo nativo mediante JIT (Just-In-Time Compiler).
Gestiona memoria automÃ¡tica (recolecciÃ³n de basura).
Es especÃ­fica de cada sistema operativo y arquitectura.

ğŸ”¹ Clave: 
El programador compila una sola vez; la JVM se encarga de adaptar la ejecuciÃ³n a cualquier plataforma.

Â¿QuÃ© es el bytecode y los ficheros .class?

Bytecode:
CÃ³digo intermedio independiente de la plataforma, generado por el compilador javac. No es cÃ³digo mÃ¡quina, sino un lenguaje de bajo nivel entendido Ãºnicamente por la JVM.

Ficheros .class:
Contienen el bytecode de una clase Java. Son binarios (no legibles directamente) y portables a cualquier sistema con JVM instalada.

# Estructura tÃ­pica despuÃ©s de compilar
mi-proyecto/
â”œâ”€â”€ HolaMundo.java   â† cÃ³digo fuente (texto legible)
â””â”€â”€ HolaMundo.class  â† bytecode (binario, para la JVM)

âš ï¸ Nota: Los ficheros .class no son ejecutables por el sistema operativo; solo la JVM puede ejecutarlos.

ğŸ’¡ Resumen clave
javac
Compilador: .java â†’ .class (bytecode)

java
Lanza la JVM para ejecutar el bytecode

Bytecode
CÃ³digo intermedio independiente de la plataforma

.class
Fichero binario que contiene el bytecode

JVM
MÃ¡quina virtual que ejecuta el bytecode en cualquier sistema

Portabilidad
Mismo .class funciona en Windows, Linux, macOS, etc.

ğŸ” Comandos Ãºtiles adicionales:

javac -version    # Ver versiÃ³n del compilador
java -version     # Ver versiÃ³n de la JVM instalada
javac *.java      # Compilar todos los .java del directorio actual
java MiClase arg1 arg2  # Pasar argumentos al mÃ©todo main (args[0], args[1]...)

11. En el cÃ³digo anterior de la clase Punto Â¿QuÃ© es new? Â¿QuÃ© es un constructor? Pon un ejemplo de constructor en una clase Empleado que tenga DNI, nombre y apellidos
Respuesta

Â¿QuÃ© es new?

new es un operador que realiza tres acciones fundamentales:
Reserva memoria en el heap para el nuevo objeto.
Invoca al constructor de la clase para inicializar el estado del objeto.
Devuelve una referencia al objeto reciÃ©n creado (direcciÃ³n de memoria).

Punto p = new Punto(3.0, 4.0);
//         â†‘â†‘â†‘
//         1. Reserva memoria para un Punto
//         2. Llama al constructor Punto(double, double)
//         3. Devuelve la referencia al objeto creado

âš ï¸ Sin new no hay objeto real, solo hay una variable de referencia que apunta a null.

Â¿QuÃ© es un constructor?

Un constructor es un mÃ©todo especial que:
Tiene exactamente el mismo nombre que la clase.
No tiene tipo de retorno (ni siquiera void).
Se ejecuta automÃ¡ticamente al crear un objeto con new.
Sirve para inicializar el estado del objeto (asignar valores iniciales a los atributos).

ğŸ”¹ Tipos de constructores:

Constructor por defecto:
Si no defines ningÃºn constructor, el compilador genera uno sin parÃ¡metros que no hace nada:

public Punto() { } // Generado automÃ¡ticamente si no hay otros constructores

Constructor parametrizado:
Define parÃ¡metros para inicializar los atributos al crear el objeto:

public Punto(double x, double y) {
    this.x = x;
    this.y = y;
}

âš ï¸ Regla importante:
Si defines al menos un constructor explÃ­cito, el compilador ya no genera el constructor por defecto automÃ¡ticamente.

Ejemplo: Clase Empleado con constructor

class Empleado {
    // Atributos
    String dni;
    String nombre;
    String apellidos;
    
    // Constructor parametrizado
    Empleado(String dni, String nombre, String apellidos) {
        this.dni = dni;
        this.nombre = nombre;
        this.apellidos = apellidos;
    }
    
    // MÃ©todo para mostrar los datos del empleado
    void mostrarDatos() {
        System.out.println("DNI: " + dni);
        System.out.println("Nombre completo: " + nombre + " " + apellidos);
    }
}

// Clase de prueba
public class PruebaEmpleado {
    public static void main(String[] args) {
        // Crear una instancia usando new + constructor
        Empleado emp = new Empleado("12345678A", "Ana", "GarcÃ­a LÃ³pez");
        
        // Usar el objeto
        emp.mostrarDatos();
    }
}

ğŸ’¡ Resumen clave

>new
Operador que reserva memoria, invoca al constructor y devuelve una referencia.

>Constructor
MÃ©todo especial sin retorno que inicializa el estado de un objeto al crearse.

>this
Hace referencia al objeto actual; Ãºtil para diferenciar parÃ¡metros de atributos.

>Sin constructor explÃ­cito
El compilador genera uno por defecto (sin parÃ¡metros).

>Con constructor explÃ­cito
El constructor por defecto desaparece a menos que lo definas tÃº.

12. Â¿QuÃ© es la referencia this? Â¿Se llama igual en todos los lenguajes? Pon un ejemplo del uso de this en la clase Punto
Respuesta

Referencia this en Java

Â¿QuÃ© es this?

this es una referencia implÃ­cita que apunta al objeto actual sobre el que se estÃ¡ ejecutando un mÃ©todo o constructor. Es una palabra reservada que solo existe dentro de mÃ©todos y constructores de instancia (no en mÃ©todos static).

ğŸ”¹ Usos principales de this:
Diferenciar atributos de parÃ¡metros locales cuando tienen el mismo nombre:

this.atributo = parametro;

Invocar a otro constructor de la misma clase (debe ser la primera instrucciÃ³n del constructor):

this(otrosParametros);

Devolver la referencia al objeto actual desde un mÃ©todo:

return this;

Pasar el objeto actual como argumento a otro mÃ©todo:

otroMetodo(this);

âš ï¸ Importante: this no existe en mÃ©todos static porque estos pertenecen a la clase, no a una instancia concreta.

Â¿Se llama igual en todos los lenguajes?

No. La referencia al objeto actual varÃ­a segÃºn el lenguaje:

Java, C++, C#
this

Python
self (como primer parÃ¡metro explÃ­cito)

JavaScript
this (comportamiento mÃ¡s complejo, depende del contexto)

Ruby
self

PHP
$this

Kotlin
this

Ejemplo: Uso de this en la clase Punto

class Punto {
    double x;
    double y;
    
    // Constructor usando 'this' para diferenciar parÃ¡metros de atributos
    Punto(double x, double y) {
        this.x = x;   // this.x â†’ atributo | x â†’ parÃ¡metro
        this.y = y;   // this.y â†’ atributo | y â†’ parÃ¡metro
    }
    

ğŸ’¡ Resumen clave

this â†’ referencia al objeto actual dentro de mÃ©todos/constructores de instancia.
No usable en mÃ©todos static (no hay objeto asociado).
No es universal: otros lenguajes usan self, $this, etc.
Casos de uso frecuentes: resolver ambigÃ¼edad nombre, delegar constructores, encadenar mÃ©todos.

13. AÃ±ade ahora otro nuevo mÃ©todo que se llame distanciaA, que reciba un Punto como parÃ¡metro y calcule la distancia entre this y el punto proporcionado
Respuesta

MÃ©todo distanciaA en la clase Punto

class Punto {
    double x;
    double y;
    
    // Constructor
    Punto(double x, double y) {
        this.x = x;
        this.y = y;
    }
    

ğŸ’¡ Notas clave

FÃ³rmula utilizada:
distancia = âˆš[(xâ‚‚ - xâ‚)Â² + (yâ‚‚ - yâ‚)Â²]

Uso de this:
this.x y this.y representan las coordenadas del punto actual sobre el que se invoca el mÃ©todo. otro.x y otro.y son las coordenadas del punto recibido como parÃ¡metro.

SimetrÃ­a:
La distancia es simÃ©trica: p1.distanciaA(p2) = p2.distanciaA(p1).

ReutilizaciÃ³n:
El mÃ©todo calculaDistanciaAOrigen() podrÃ­a reescribirse usando distanciaA():

double calculaDistanciaAOrigen() {
    return this.distanciaA(new Punto(0.0, 0.0));
}

âš ï¸ Importante: El parÃ¡metro otro es una referencia a otro objeto Punto. Si se pasara null, se producirÃ­a un NullPointerException al acceder a otro.x o otro.y. En cÃ³digo robusto, se deberÃ­a validar:

if (otro == null) {
    throw new IllegalArgumentException("El punto no puede ser null");
}

14. El paso del Punto como parÃ¡metro a un mÃ©todo, es por copia o por referencia, es decir, si se cambia el valor de algÃºn atributo del punto pasado como parÃ¡metro, dichos cambios afectan al objeto fuera del mÃ©todo? Â¿QuÃ© ocurre si en vez de un Punto, se recibiese un entero (int) y dicho entero se modificase dentro de la funciÃ³n?
Respuesta

 Paso de parÃ¡metros en Java â€“ Â¿Por valor o por referencia?

Concepto fundamental
Java siempre pasa parÃ¡metros por valor (pass-by-value), nunca por referencia en el sentido estricto del tÃ©rmino. Sin embargo, el comportamiento difiere segÃºn el tipo de dato:
>>
Primitivos (int, double...)
El valor literal
âŒ No
>>
Objetos (Punto, String...)
El valor de la referencia (direcciÃ³n de memoria)
âœ… SÃ­, si modificas sus atributos
>>
âŒ No, si reasignas la referencia

Caso 1: Paso de un objeto (Punto)

class Punto {
    double x, y;
    
    Punto(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    void modificarDentro(Punto p) {
        p.x = 100;      // âœ… Modifica el atributo del objeto real

ğŸ”¹ ExplicaciÃ³n:
Al llamar a modificarDentro(p1), Java copia el valor de la referencia p1 (es decir, la direcciÃ³n de memoria del objeto).
Dentro del mÃ©todo, p es una copia de esa referencia, pero ambas (p1 y p) apuntan al mismo objeto en el heap.
Al modificar p.x o p.y, se altera el objeto real â†’ cambios visibles fuera.
Al hacer p = new Punto(...), solo se modifica la copia local p; p1 sigue apuntando al objeto original.

Caso 2: Paso de un primitivo (int)

class Ejemplo {
    void modificarEntero(int n) {
        n = n * 10;  // âŒ Modifica solo la copia local
        System.out.println("Dentro del mÃ©todo: " + n); // 50
    }
}

public class Prueba {
    public static void main(String[] args) {
        int numero = 5;

ğŸ”¹ ExplicaciÃ³n:
Se copia el valor literal 5 a la variable local n del mÃ©todo.
Cualquier cambio sobre n afecta solo a esa copia local.
La variable original numero permanece intacta.

ğŸ’¡ Resumen visual


Paso de objeto (Punto):
main:  p1 â”€â”€â”€â”€â”€â”€â”€â”€â†’ [Punto en heap: x=3, y=4]
                    â†‘
mÃ©todo: p â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â† copia de la referencia (misma direcciÃ³n)
       p.x = 100 â†’ modifica el OBJETO REAL âœ“

Paso de primitivo (int):
main:  numero = 5
                    â†“
mÃ©todo: n = 5       â† copia del valor


âš ï¸ Error comÃºn

âŒ Mito: "Java pasa objetos por referencia".
âœ… Realidad: Java pasa el valor de la referencia por valor (pass-by-value of the reference). Es una diferencia sutil pero fundamental.

ğŸ”‘ ConclusiÃ³n

>Modificar atributos/valor interno
âœ… SÃ­ afecta
âŒ No afecta

>Reasignar la variable del mÃ©todo
âŒ No afecta
âŒ No afecta

15. Â¿QuÃ© es el mÃ©todo toString() en Java? Â¿Existe en otros lenguajes? Pon un ejemplo de toString() en la clase Punto en Java
Respuesta

MÃ©todo toString() en Java

Â¿QuÃ© es toString()?

toString() es un mÃ©todo heredado de la clase Object (la superclase de todas las clases en Java) que devuelve una representaciÃ³n textual del objeto. Su firma es:

public String toString()

ğŸ”¹ PropÃ³sito:
Proporcionar una cadena legible que describa el estado del objeto. Es Ãºtil para:
DepuraciÃ³n (System.out.println(objeto))
Logging
Mostrar informaciÃ³n al usuario

ğŸ”¹ Comportamiento por defecto:
Si no se sobrescribe, toString() devuelve algo como:

nombrePaquete.NombreClase@hashCodeHexadecimal
// Ejemplo: Punto@1b6d3586

Â¿Existe en otros lenguajes?

SÃ­, aunque con nombres distintos:

>Java
toString()
Heredado de Object

>C#
ToString()
Heredado de Object

>Python
__str__() / __repr__()
str(objeto) llama a __str__()

>C++
No estÃ¡ndar
Se suele implementar manualmente

>JavaScript
toString()
Disponible en muchos objetos nativos

>Ruby
to_s
"to string"

Ejemplo: toString() en la clase Punto

class Punto {
    double x;
    double y;
    
    Punto(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    // Sobrescritura de toString()
    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
    
    double distanciaA(Punto otro) {
        double dx = this.x - otro.x;
        double dy = this.y - otro.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

public class PruebaPunto {
    public static void main(String[] args) {
        Punto p1 = new Punto(3.0, 4.0);
        Punto p2 = new Punto(6.0, 8.0);
        
        // Al imprimir un objeto, Java llama automÃ¡ticamente a toString()
        System.out.println(p1);           // Salida: (3.0, 4.0)
        System.out.println(p2);           // Salida: (6.0, 8.0)
        
        // TambiÃ©n se puede invocar explÃ­citamente
        System.out.println("Distancia entre " + p1.toString() + 
                           " y " + p2.toString() + 
                           ": " + p1.distanciaA(p2));
        // Salida: Distancia entre (3.0, 4.0) y (6.0, 8.0): 5.0
    }
}

ğŸ’¡ Notas clave

@Override: AnotaciÃ³n opcional pero recomendada que indica que estÃ¡s sobrescribiendo un mÃ©todo de una superclase. El compilador verifica que el mÃ©todo exista en la jerarquÃ­a.
>ConcatenaciÃ³n automÃ¡tica: 
Cuando haces System.out.println(objeto), Java invoca internamente objeto.toString().
>Buena prÃ¡ctica: 
Un toString() bien implementado facilita enormemente la depuraciÃ³n y el mantenimiento del cÃ³digo.
>Formato flexible: 
Puedes personalizar el formato segÃºn tus necesidades (CSV, JSON, etc.).

// Ejemplos alternativos de toString()
return "Punto[x=" + x + ", y=" + y + "]";     // MÃ¡s descriptivo
return x + ";" + y;                           // Formato CSV
return String.format("(%.2f, %.2f)", x, y);   // Formato con 2 decimales

âš ï¸ Importante: toString() debe ser rÃ¡pido y no tener efectos secundarios (no modificar el estado del objeto).

16. Reflexiona: Â¿una clase es como un struct en C? Â¿QuÃ© le falta al struct para ser como una clase y las variables de ese tipo ser instancias?
Respuesta

Â¿Es una clase como un struct en C?
Semejanza superficial
SÃ­, hay una similitud estructural bÃ¡sica: tanto una clase como un struct en C permiten agrupar varias variables relacionadas bajo un mismo tipo. Por ejemplo:

C: 

// Struct en C
struct Punto {
    double x;
    double y;
};

Java: 

// Clase en Java (mÃ­nima)
class Punto {
    double x;
    double y;
}

En ambos casos creamos un tipo compuesto que representa una entidad con mÃºltiples atributos.

Diferencias fundamentales: Â¿QuÃ© le falta al struct?
Un struct en C es solo una agrupaciÃ³n de datos. Para ser equivalente a una clase le faltan elementos esenciales del paradigma orientado a objetos:

>>Comportamiento (mÃ©todos)
Un struct no puede contener funciones. El comportamiento se define fuera del struct, como funciones independientes que reciben un puntero al struct:

C:

void mover(struct Punto* p, double dx, double dy) {
    p->x += dx;
    p->y += dy;
}

En una clase, los mÃ©todos estÃ¡n integrados en la definiciÃ³n del tipo y operan naturalmente sobre sus atributos.

>>Encapsulamiento
En C todos los campos de un struct son pÃºblicos por naturaleza. No existe un mecanismo nativo para ocultar datos o controlar el acceso (private, protected). En Java sÃ­.

>>Herencia y polimorfismo
Un struct no puede heredar de otro ni formar jerarquÃ­as. Tampoco permite tratar objetos de tipos distintos a travÃ©s de una interfaz comÃºn (polimorfismo).

>>Constructores y destructores
En C no hay inicializaciÃ³n automÃ¡tica al crear un struct. Debes inicializar manualmente cada campo. En Java los constructores garantizan que el objeto nazca en un estado vÃ¡lido.

>>Identidad como tipo completo
En C un struct es solo un contenedor de datos. En POO, una clase define una abstracciÃ³n completa: quÃ© es el objeto, quÃ© sabe (estado) y quÃ© hace (comportamiento).

VisiÃ³n histÃ³rica
C++ naciÃ³ precisamente para resolver esta limitaciÃ³n: aÃ±adir clases (y POO) a C. De hecho, en C++ un struct es tÃ©cnicamente casi idÃ©ntico a una class, salvo que su visibilidad por defecto es public en lugar de private.
En C puro se pueden simular algunos conceptos POO usando punteros a funciones dentro de structs, pero es una tÃ©cnica manual, frÃ¡gil y sin soporte del lenguaje.

ğŸ’¡ ConclusiÃ³n reflexiva

Un struct en C es el germen estructural de una clase: permite agrupar datos relacionados. Pero una clase es una abstracciÃ³n completa que une datos y comportamiento, protege su estado interno y permite relaciones dinÃ¡micas entre tipos (herencia, polimorfismo).

ğŸ”¹ struct â†’ "Â¿QuÃ© tiene este objeto?" (solo datos)
ğŸ”¹ Clase â†’ "Â¿QuÃ© es este objeto y quÃ© puede hacer?" (datos + comportamiento + identidad)

La evoluciÃ³n de struct a clase representa el salto de la organizaciÃ³n de datos a la modelizaciÃ³n de entidades del mundo real.

17. Quitemos un poco de magia a todo esto: Â¿Como se podrÃ­a â€œemularâ€, con struct en C, la clase Punto, con su funciÃ³n para calcular la distancia al origen? Â¿QuÃ© ha pasado con this?
Respuesta

 Emulando una clase Java con struct en C â€“ Â¿DÃ³nde estÃ¡ this?

La "magia" destapada: this es un parÃ¡metro implÃ­cito

En lenguajes orientados a objetos como Java, this no es magia: es simplemente un parÃ¡metro oculto que el compilador pasa automÃ¡ticamente a cada mÃ©todo de instancia. El mÃ©todo recibe una referencia al objeto sobre el que se invoca.

En C no hay magia: ese parÃ¡metro debe ser explÃ­cito.

EmulaciÃ³n en C puro

#include <stdio.h>
#include <math.h>

// 1. DefiniciÃ³n del struct (solo datos)
struct Punto {
    double x;
    double y;
};

// 2. FunciÃ³n "mÃ©todo" externa: recibe un PUNTERO al struct como primer parÃ¡metro
//    Â¡Este puntero ES el equivalente a 'this'!
double calculaDistanciaAOrigen(struct Punto* this) {
    return sqrt(this->x * this->x + this->y * this->y);
}

// 3. Otra funciÃ³n Ãºtil: distancia entre dos puntos
double distanciaA(struct Punto* this, struct Punto* otro) {
    double dx = this->x - otro->x;
    double dy = this->y - otro->y;
    return sqrt(dx * dx + dy * dy);
}

// 4. Ejemplo de uso
int main() {
    struct Punto p1 = {3.0, 4.0};
    struct Punto p2 = {0.0, 0.0};
    
    // Llamada "manual" pasando explÃ­citamente el objeto como primer argumento
    double d1 = calculaDistanciaAOrigen(&p1);
    printf("Distancia de p1 al origen: %.2f\n", d1);  // 5.00
    
    double d2 = distanciaA(&p1, &p2);
    printf("Distancia entre p1 y p2: %.2f\n", d2);    // 5.00
    
    return 0;
}

Â¿DÃ³nde estÃ¡ this?

java: p1.distanciaA(p2)
c: distanciaA(&p1, &p2)

java: this se pasa implÃ­citamente
c: El puntero this se pasa explÃ­citamente

java: El compilador lo inyecta
c: El programador lo escribe

ğŸ”¹ En Java:

p1.distanciaA(p2);  // El compilador transforma internamente en:
                    // distanciaA(this = p1, otro = p2)

ğŸ”¹ En C:

distanciaA(&p1, &p2);  // TÃº escribes explÃ­citamente:
                       // this = &p1, otro = &p2

Â¿Se puede emular aÃºn mÃ¡s? (Opcional: punteros a funciÃ³n)

En C avanzado se pueden incluir punteros a funciÃ³n dentro del struct para simular mÃ©todos "vinculados":


#include <stdio.h>
#include <math.h>

typedef struct Punto Punto;

struct Punto {
    double x;
    double y;
    // Puntero a funciÃ³n que actÃºa como "mÃ©todo"
    double (*distanciaAOrigen)(Punto* this);
};

// ImplementaciÃ³n de la "funciÃ³n-mÃ©todo"
double metodo_distanciaAOrigen(Punto* this) {
    return sqrt(this->x * this->x + this->y * this->y);
}

// Constructor manual
Punto crearPunto(double x, double y) {
    Punto p = {x, y, metodo_distanciaAOrigen};
    return p;
}

int main() {
    Punto p = crearPunto(3.0, 4.0);
    
    // Â¡Parece un mÃ©todo! Pero sigue siendo una llamada explÃ­cita:
    double d = p.distanciaAOrigen(&p);  // AÃºn debes pasar &p explÃ­citamente
    printf("Distancia: %.2f\n", d);
    
    return 0;
}

âš ï¸ LimitaciÃ³n: Aunque el puntero a funciÃ³n estÃ¡ dentro del struct, sigues necesitando pasar &p explÃ­citamente. C no tiene sintaxis para ocultar ese parÃ¡metro como hace Java.

ğŸ’¡ ConclusiÃ³n clave

this no es magia: 
es un parÃ¡metro que en Java se pasa implÃ­citamente y en C debes pasar explÃ­citamente.

Un struct es solo datos: 
el comportamiento vive fuera, en funciones que reciben un puntero al struct.
La POO automatiza lo que en C haces manualmente: 
agrupar datos + pasar referencias implÃ­citamente + sintaxis cÃ³moda (objeto.metodo()).

C++ naciÃ³ para resolver esto: 
aÃ±adiÃ³ clases a C precisamente para evitar este "paso manual de this".

ğŸ” ReflexiÃ³n final: 
La programaciÃ³n orientada a objetos no inventa nada nuevo a nivel de mÃ¡quina. Solo automatiza y encapsula patrones que ya existÃ­an en lenguajes procedimentales como C. La "magia" es en realidad conveniencia sintÃ¡ctica y organizaciÃ³n conceptual.
