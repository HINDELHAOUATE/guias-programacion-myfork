TEMA 2. Encapsulaci√≥n
1. En Programaci√≥n Orientada a Objetos (POO), ¬øQu√© 
buscan la encapsulaci√≥n y la ocultaci√≥n de informaci√≥n? 
Enumera brevemente algunas ventajas de la ocultaci√≥n 
de informaci√≥n.
Encapsulaci√≥n y Ocultaci√≥n de Informaci√≥n en POO (Java)
¬øQu√© buscan?
La encapsulaci√≥n y la ocultaci√≥n de informaci√≥n buscan proteger los datos internos de un 
objeto y controlar c√≥mo se accede o modifica ese estado.
En Java se logra usando modificadores de acceso (private, public, protected) y m√©todos 
getters/setters.
üéØ
Ventajas de la ocultaci√≥n de informaci√≥n
1. Seguridad de datos
Evita cambios incorrectos en los atributos desde fuera de la clase.
2. Control del acceso
Permite validar datos antes de modificarlos (ej: no permitir edad negativa).
3. Mantenimiento m√°s f√°cil
Puedes cambiar la implementaci√≥n interna sin afectar el c√≥digo que usa la clase.
4. Menor acoplamiento
Las clases dependen menos unas de otras ‚Üí
 c√≥digo m√°s modular.
5. Mejor organizaci√≥n y claridad
Cada clase controla su propio comportamiento.
üìå
Ejemplo simple en Java
class Persona {
private int edad;   // atributo oculto
public int getEdad() {
return edad;
}
public void setEdad(int edad) {
if (edad >= 0) {
this.edad = edad;
}
}
}
üëâ
 Aqu√≠ no se puede modificar edad directamente, solo mediante m√©todos controlados.
2. ¬øQu√© se entiende por la interfaz p√∫blica de un objeto o 
clase en POO? Describe brevemente c√≥mo se relaciona 
con la ocultaci√≥n de informaci√≥n.
‚úÖ
¬øQu√© es la interfaz p√∫blica de una clase u objeto en POO?
La interfaz p√∫blica es el conjunto de m√©todos y atributos accesibles desde fuera de la 
clase (normalmente los public) que permiten interactuar con el objeto.
üëâ
 Es lo que otras clases pueden ver y usar.
En Java, est√° formada principalmente por:
M√©todos public
(En general, no se recomienda atributos public)
üîé
Relaci√≥n con la ocultaci√≥n de informaci√≥n
La interfaz p√∫blica expone solo lo necesario y mantiene ocultos los detalles internos 
(private).
Lo visible ‚Üí
 comportamiento (qu√© puede hacer el objeto).
Lo oculto ‚Üí
 implementaci√≥n interna (c√≥mo lo hace).
Esto permite:
Proteger los datos internos.
Cambiar la implementaci√≥n sin afectar al c√≥digo que usa la clase.
Reducir errores y acoplamiento.
üìå
Ejemplo en Java
class CuentaBancaria {
private double saldo;  // oculto
public void depositar(double cantidad) {
if (cantidad > 0) {
}
saldo += cantidad;
}
public double getSaldo() {
return saldo;
}
}
‚úî
 La interfaz p√∫blica ‚Üí
 depositar() y getSaldo()
‚úñ
 El atributo saldo est√° oculto.
En resumen:
La interfaz p√∫blica define c√≥mo se usa el objeto, mientras que la ocultaci√≥n de 
informaci√≥n protege c√≥mo est√° implementado internamente.
3. Brevemente: ¬øPor qu√© hay que ser conscientes y 
dise√±ar con cuidado la interfaz p√∫blica de una clase? ¬øEs 
f√°cil cambiarla?
‚úÖ
¬øPor qu√© hay que dise√±ar con cuidado la interfaz p√∫blica de una clase?
La interfaz p√∫blica es el contrato entre la clase y el resto del programa.
Todo el c√≥digo que use esa clase depende de esos m√©todos (public), por eso 
deben estar bien pensados: claros, necesarios y seguros.
üëâ
Si la interfaz est√° mal dise√±ada puede causar:
Uso incorrecto de la clase
C√≥digo dif√≠cil de mantener
Errores en muchas partes del programa
‚ùå
¬øEs f√°cil cambiarla?
No. Cambiar la interfaz p√∫blica es dif√≠cil porque puede romper todo el c√≥digo 
que ya la utiliza.
En proyectos grandes eso significa modificar muchas clases y archivos.
üëâ
Por eso en Java y en POO se intenta dise√±ar bien la interfaz desde el 
principio y mantenerla estable.
4. ¬øQu√© son las invariantes de clase y por qu√© la 
ocultaci√≥n de informaci√≥n nos ayuda?
‚úÖ
 ¬øQu√© son las invariantes de clase?
Las invariantes de clase son condiciones o reglas que siempre deben 
cumplirse para que un objeto est√© en un estado v√°lido.
 Se deben cumplir despu√©s de crear el objeto y despu√©s de ejecutar cualquier 
m√©todo p√∫blico.
üëâ
 Ejemplos:
edad >= 0
saldo >= 0
fechaInicio ‚â§ fechaFin
üîé
 ¬øPor qu√© ayuda la ocultaci√≥n de informaci√≥n?
Porque al hacer los atributos private, solo la propia clase puede modificarlos 
mediante m√©todos controlados.
 As√≠ podemos validar los datos y asegurar que las invariantes siempre se 
cumplan.
üëâ
 Si los atributos fueran public, cualquier clase podr√≠a cambiar valores y 
romper las invariantes.
üìå
 Ejemplo en Java
class CuentaBancaria {
    private double saldo;   // Invariante: saldo >= 0
    public void retirar(double cantidad) {
        if (cantidad <= saldo) {
            saldo -= cantidad;
        }
    }
}
‚úî
 La clase controla el saldo ‚Üí
 la invariante se mantiene.
 
‚úñ
 Sin ocultaci√≥n, alguien podr√≠a poner saldo = -100.
5. Pon un ejemplo de una clase Punto en Java, con dos 
coordenadas, x e y, de tipo double, con un m√©todo 
calcularDistanciaAOrigen, y que haga uso de la 
ocultaci√≥n de informaci√≥n. ¬øCu√°l es la interfaz p√∫blica de 
la clase Punto? ¬øQu√© significa public y private?
‚úÖ
Ejemplo de clase Punto en Java con encapsulaci√≥n
class Punto {
private double x;
private double y;
public Punto(double x, double y) {
this.x = x;
this.y = y;
}
public double calcularDistanciaAOrigen() {
return Math.sqrt(x * x + y * y);
}
public double getX() { return x; }
public double getY() { return y; }
}
üîé
¬øCu√°l es la interfaz p√∫blica de la clase Punto?
La interfaz p√∫blica son los elementos accesibles desde fuera:
Punto(double x, double y) ‚Üí
 constructor
calcularDistanciaAOrigen()
getX()
getY()
ÔøΩ
ÔøΩ
 Son los m√©todos public que otras clases pueden usar.
üìå
¬øQu√© significan public y private?
public ‚Üí
 accesible desde cualquier clase.
private ‚Üí
 solo accesible dentro de la propia clase.
üëâ
 Aqu√≠ x e y est√°n ocultos (private) para proteger los datos y controlar su uso mediante 
m√©todos p√∫blicos.
6. En Java, ¬øA qui√©nes se pueden aplicar los 
modificadores public o private?
En Java, los modificadores public y private se pueden aplicar a:
‚úÖ
1. Atributos (variables de instancia o de clase)
Para controlar qui√©n puede acceder a los datos.
private int edad;
public String nombre;
‚úÖ
2. M√©todos
Para decidir desde d√≥nde se pueden llamar.
public void mostrar() { }
private void calcular() { }
‚úÖ
3. Clases internas (inner classes)
Las clases dentro de otra clase pueden ser public o private.
private class Nodo { }
‚ö†
Importante
Las clases principales (top-level) solo pueden ser public o sin modificador 
(no pueden ser private).
üëâ
En resumen:
public y private se usan en atributos, m√©todos y clases internas para 
controlar el acceso y aplicar la encapsulaci√≥n.
7. En POO, la visibilidad puede ser p√∫blica o privada, 
pero ¬øexisten m√°s tipos de visibilidad? ¬øQu√© ocurre en 
Java? ¬øY en otros lenguajes?
S√≠, adem√°s de p√∫blica y privada, en POO existen m√°s niveles de visibilidad.
‚úÖ
En Java
Java tiene 4 niveles de visibilidad:
1. public ‚Üí
 accesible desde cualquier clase.
2. private ‚Üí
 solo dentro de la misma clase.
3. protected ‚Üí
 accesible en la misma clase, subclases y mismo paquete.
4. (sin modificador) package-private ‚Üí
 accesible solo dentro del mismo 
paquete.
üëâ
Ejemplo:
public class A {
private int x;
protected int y;
int z;        
// package-private
public int w;
}
‚úÖ
En otros lenguajes
Depende del lenguaje:
C++ ‚Üí
 public, private, protected
C# ‚Üí
 public, private, protected, internal, protected internal
Python ‚Üí
 no hay modificadores estrictos, pero se usan convenciones (_x, 
__x)
üëâ
Conclusi√≥n:
S√≠, hay m√°s tipos de visibilidad. Java tiene 4 niveles para controlar mejor el 
acceso y aplicar encapsulaci√≥n.
8. Responde: Los miembros de instancia privados de un 
objeto est√°n ocultos para (a) otras clases o (b) otras 
instancias, aunque sean de la misma clase. Pon un 
ejemplo a√±adiendo un m√©todo 
calcularDistanciaAPunto(Punto otro) y explica la 
respuesta.
La respuesta correcta es: (a) otras clases, pero no (b) otras instancias de la 
misma clase.
En Java, los atributos private est√°n ocultos para otras clases, pero una 
instancia puede acceder a los privados de otra instancia de la misma clase 
dentro de un m√©todo de la clase.
‚úÖ
 Ejemplo con Punto
class Punto {
    private double x;
    private double y;
    public Punto(double x, double y) {
        this.x = x;
        this.y = y;
    }
    public double calcularDistanciaAOrigen() {
        return Math.sqrt(x * x + y * y);
    }
    // M√©todo que calcula la distancia a otro punto
    public double calcularDistanciaAPunto(Punto otro) {
        double dx = this.x - otro.x;  // puedo acceder a 'x' de otra instancia
        double dy = this.y - otro.y;  // puedo acceder a 'y' de otra instancia
        return Math.sqrt(dx * dx + dy * dy);
}
}
üîé
Explicaci√≥n
x e y son privados, por lo que ninguna otra clase puede acceder a ellos 
directamente.
Sin embargo, dentro de la propia clase Punto, podemos acceder a x e y de 
cualquier instancia de Punto, por ejemplo otro.x.
Esto permite implementar m√©todos como calcularDistanciaAPunto sin 
violar la encapsulaci√≥n.
9. ¬øQu√© son los m√©todos "getter" y "setter" en los 
lenguajes orientados a objetos?
‚úÖ
M√©todos "getter" y "setter" en POO
En los lenguajes orientados a objetos, los getters y setters son m√©todos que 
permiten acceder y modificar atributos privados de una clase de forma 
controlada.
üîπ
Getter
Sirve para obtener el valor de un atributo privado.
Siempre devuelve el valor del atributo.
public double getX() {
return x;
}
üîπ
Setter
Sirve para modificar el valor de un atributo privado.
Permite validar o controlar el valor antes de asignarlo.
public void setX(double x) {
if (x >= 0) { // ejemplo de validaci√≥n
this.x = x;
}
}
ÔøΩ
ÔøΩ
Por qu√© se usan
Mantener la ocultaci√≥n de informaci√≥n (private).
Evitar que el estado del objeto quede inconsistente.
Permitir cambiar la implementaci√≥n interna sin afectar a otras clases.
10. Cuando nos referimos a que la ocultaci√≥n de 
informaci√≥n mejora la "seguridad" del programa, ¬ønos 
referimos a que no pueda ser "hackeado"?
No exactamente.
Cuando hablamos de que la ocultaci√≥n de informaci√≥n mejora la ‚Äúseguridad‚Äù 
del programa‚Äù en POO y Java, no nos referimos a que el programa sea 
inmune a hackers o ataques externos, sino a que los datos internos de los 
objetos no pueden ser modificados accidentalmente o de forma incorrecta 
desde otras partes del c√≥digo.
üëâ
Es una seguridad a nivel de programaci√≥n, tambi√©n llamada integridad de 
datos:
Los atributos private solo se pueden cambiar mediante m√©todos 
controlados (setters), donde podemos validar los valores.
Esto evita errores, inconsistencias y comportamientos inesperados 
dentro del programa.
En resumen: protege el estado de los objetos frente a errores de 
programaci√≥n, no frente a ataques externos.
11. ¬øQu√© diferencia hay entre miembro de instancia y 
miembro de clase? ¬øLos miembros de clase tambi√©n se 
pueden ocultar?
‚úÖ
Diferencia entre miembro de instancia y miembro de clase en Java:
Concepto Miembro de instancia Miembro de clase
Definici√≥n Pertenece a cada 
objeto. Cada instancia 
tiene su propia copia.
Pertenece a la clase, 
no a objetos 
individuales. Se 
declara con static.
Ejemplo private double x; en 
Punto ‚Üí
 cada punto 
tiene su propio x.
private static int 
contador; ‚Üí
 hay un 
√∫nico contador 
compartido por todos 
los objetos.
Acceso Se accede a trav√©s de 
un objeto: 
punto.getX()
Se accede a trav√©s de 
la clase: 
Punto.contador
üîé
 ¬øSe pueden ocultar los miembros de clase?
S√≠. Los miembros de clase tambi√©n se pueden declarar private o public, igual 
que los de instancia.
private static int contador; ‚Üí
 oculto para otras clases, pero accesible 
dentro de la propia clase.
Esto permite controlar el acceso y proteger la informaci√≥n compartida, 
igual que con los atributos normales.
12. Brevemente: ¬øTiene sentido que los constructores 
sean privados?
S√≠, tiene sentido que un constructor sea private en casos especiales.
Se usa para controlar la creaci√≥n de objetos.
Por ejemplo, en patrones de dise√±o como Singleton, donde solo quieres 
una √∫nica instancia de la clase.
Tambi√©n permite crear m√©todos est√°ticos que devuelvan objetos ya 
configurados (f√°bricas de objetos).
üëâ
 En general, los constructores suelen ser public, pero hacerlos private es 
√∫til para controlar y limitar la creaci√≥n de instancias.
13. ¬øC√≥mo se indican los miembros de clase en Java? Pon 
un ejemplo, en la clase Punto definida anteriormente, 
para que incluya miembros de clase que permitan saber 
cu√°les son los valores x e y m√°ximos que se han 
establecido en todos los puntos que se hayan creado 
hasta el momento.
‚úÖ
 Miembros de clase en Java
Se indican usando la palabra clave static.
Son compartidos por todos los objetos de la clase, no por cada instancia.
Se pueden usar para contar objetos, valores m√°ximos, o cualquier 
informaci√≥n global de la clase.
Ejemplo con la clase Punto
class Punto {
    private double x;
    private double y;
    // Miembros de clase (est√°ticos) para rastrear los m√°ximos
    private static double maxX = Double.NEGATIVE_INFINITY;
    private static double maxY = Double.NEGATIVE_INFINITY;
    public Punto(double x, double y) {
        this.x = x;
        this.y = y;
        // Actualizar los m√°ximos al crear un nuevo punto
        if (x > maxX) {
            maxX = x;
        }
        if (y > maxY) {
            maxY = y;
        }
    }
    public double calcularDistanciaAOrigen() {
        return Math.sqrt(x * x + y * y);
    }
    public double getX() { return x; }
    public double getY() { return y; }
    // M√©todos p√∫blicos para acceder a los m√°ximos de todos los puntos
    public static double getMaxX() { return maxX; }
    public static double getMaxY() { return maxY; }
}
üîé
 Explicaci√≥n
maxX y maxY son miembros de clase (static) ‚Üí
 compartidos por todos los 
objetos Punto.
Cada vez que se crea un nuevo punto, se actualizan los m√°ximos si 
corresponde.
Los m√©todos getMaxX() y getMaxY() forman parte de la interfaz p√∫blica 
de clase para consultar los m√°ximos.
14. Como ser√≠a un m√©todo factor√≠a dentro de la clase 
Punto para construir un Punto a partir de dos 
coordenadas, pero que las redondee al entero m√°s 
cercano. Escribe s√≥lo el c√≥digo del m√©todo, no toda la 
clase ¬øHas usado static?
S√≠, un m√©todo factor√≠a se hace static porque no necesita una instancia 
existente para crear un objeto nuevo.
‚úÖ
C√≥digo del m√©todo factor√≠a
public static Punto crearRedondeado(double x, double y) {
int xRedondeado = (int) Math.round(x);
int yRedondeado = (int) Math.round(y);
return new Punto(xRedondeado, yRedondeado);
}
static permite llamar al m√©todo como: Punto p = 
Punto.crearRedondeado(3.7, 4.2);
Devuelve un nuevo objeto Punto con las coordenadas redondeadas.
15. Cambia la implementaci√≥n de Punto. En vez de dos 
double, emplea un array interno de dos posiciones, 
intentando no modificar la interfaz p√∫blica de la clase.
Perfecto. Podemos cambiar la implementaci√≥n interna usando un array de 
dos posiciones para almacenar x e y, sin modificar la interfaz p√∫blica 
(constructores, getters y m√©todos siguen igual).
‚úÖ
Nueva implementaci√≥n de Punto
class Punto {
private double[] coordenadas = new double[2]; // [0] = x, [1] = y
// Miembros de clase para m√°ximos
private static double maxX = Double.NEGATIVE_INFINITY;
private static double maxY = Double.NEGATIVE_INFINITY;
    public Punto(double x, double y) {
        coordenadas[0] = x;
        coordenadas[1] = y;
        // Actualizar m√°ximos
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
    }
    public double calcularDistanciaAOrigen() {
        return Math.sqrt(coordenadas[0] * coordenadas[0] + coordenadas[1] * 
coordenadas[1]);
    }
    public double getX() { return coordenadas[0]; }
    public double getY() { return coordenadas[1]; }
    // M√©todos de clase
    public static double getMaxX() { return maxX; }
    public static double getMaxY() { return maxY; }
    // M√©todo factor√≠a est√°tico
    public static Punto crearRedondeado(double x, double y) {
        int xRedondeado = (int) Math.round(x);
        int yRedondeado = (int) Math.round(y);
        return new Punto(xRedondeado, yRedondeado);
    }
// M√©todo para calcular distancia a otro punto
public double calcularDistanciaAPunto(Punto otro) {
double dx = this.coordenadas[0] - otro.coordenadas[0];
double dy = this.coordenadas[1] - otro.coordenadas[1];
return Math.sqrt(dx * dx + dy * dy);
}
}
üîé
Explicaci√≥n
Internamente usamos coordenadas[0] y coordenadas[1] en vez de x y y.
La interfaz p√∫blica no cambia:
getX(), getY()
calcularDistanciaAOrigen()
calcularDistanciaAPunto(Punto otro)
m√©todo factor√≠a crearRedondeado()
m√©todos est√°ticos de m√°ximos getMaxX(), getMaxY()
Esto permite cambiar la implementaci√≥n interna sin romper el c√≥digo que ya 
usa la clase.
16. Si un atributo va a tener un m√©todo "getter" y 
"setter" p√∫blicos, ¬øno es mejor declararlo p√∫blico? ¬øCu√°l 
es la convenci√≥n m√°s habitual sobre los atributos, que 
sean p√∫blicos o privados? ¬øTiene esto algo que ver con 
las "invariantes de clase"?
No, no es mejor declararlo p√∫blico aunque tenga getter y setter.
‚úÖ
Explicaci√≥n
1. Convenci√≥n habitual
Los atributos casi siempre se declaran private.
Se accede a ellos mediante getters y setters p√∫blicos si es necesario.
Esto mantiene la ocultaci√≥n de informaci√≥n y protege los datos 
internos.
2. Por qu√© no ponerlos p√∫blicos
Si el atributo fuera public, cualquier clase podr√≠a modificarlo 
directamente, sin validaci√≥n.
Con private + setter, podemos controlar el valor y mantenerlo 
consistente.
3. Relaci√≥n con invariantes de clase
Las invariantes de clase son reglas que siempre deben cumplirse (por 
ejemplo, edad >= 0).
Los setters permiten validar antes de cambiar el valor y as√≠ proteger 
las invariantes.
Si el atributo fuera p√∫blico, cualquiera podr√≠a romper la invariante sin 
control.
En resumen:
Se declaran atributos private, aunque tengan getter y setter p√∫blicos, para 
proteger los datos y mantener las invariantes de clase.
17. ¬øQu√© significa que una clase sea inmutable? ¬øqu√© es 
un m√©todo modificador? ¬øUn m√©todo modificador es 
siempre un "setter"? ¬øTiene ventajas que una clase sea 
inmutable?
‚úÖ
Clase inmutable
Una clase es inmutable cuando, una vez creada una instancia, sus atributos 
no pueden cambiar.
Todos los atributos suelen ser private y no hay setters.
Cualquier ‚Äúcambio‚Äù se hace creando un nuevo objeto.
Ejemplo simple:
class PuntoInmutable {
private final double x;
private final double y;
public PuntoInmutable(double x, double y) {
this.x = x;
this.y = y;
}
public double getX() { return x; }
public double getY() { return y; }
}
‚úÖ
M√©todo modificador
Es un m√©todo que cambia el estado interno de un objeto.
No siempre es un setter: puede ser cualquier m√©todo que modifique atributos 
privados.
Ejemplo:
public void mover(double dx, double dy) {
this.x += dx;
this.y += dy;
}
Aqu√≠ mover() modifica el estado, pero no es un setter tradicional.
‚úÖ
Ventajas de que una clase sea inmutable
1. Seguridad de datos ‚Üí
 no se puede cambiar accidentalmente.
2. M√°s f√°cil de razonar y depurar ‚Üí
 el objeto siempre mantiene su estado.
3. Hilos seguros (thread-safe) ‚Üí
 no hace falta sincronizaci√≥n para leer 
objetos.
4. √ötil en colecciones y claves de mapas ‚Üí
 el objeto no cambia mientras se 
usa como clave.
En resumen:
Inmutable ‚Üí
 atributos nunca cambian despu√©s de la creaci√≥n.
M√©todo modificador ‚Üí
 cualquier m√©todo que cambie atributos, no solo 
setters.
Ventajas ‚Üí
 seguridad, facilidad de mantenimiento y hilos seguros.
18. ¬øEs recomendable incluir m√©todos "setter" siempre y 
como convenci√≥n?
No, no es recomendable incluir m√©todos setter siempre.
‚úÖ
Explicaci√≥n
1. Convenci√≥n
La convenci√≥n es hacer privados los atributos y solo incluir getters y 
setters cuando realmente se necesite modificar el valor desde fuera.
No todos los atributos necesitan ser modificables; algunos pueden ser 
solo de lectura (getter sin setter).
2. Raz√≥n principal
Los setters permiten cambiar el estado del objeto. Si los ponemos 
siempre, podemos romper invariantes de clase o introducir errores.
Para clases inmutables, no se usan setters, lo que da m√°s seguridad y 
estabilidad.
3. Regla pr√°ctica
Solo a√±adir setters cuando tenga sentido permitir cambios 
controlados.
Para atributos que no deber√≠an cambiar, no poner setter.
En resumen:
No todos los atributos necesitan setters. Se usan solo cuando es necesario 
modificar valores de forma controlada y proteger las invariantes de clase.
19. ¬øLa clase String en Java es mutable o inmutable? 
¬øQu√© ocurre al concatenar dos cadenas? ¬øQu√© debemos 
hacer si vamos a hacer una operaci√≥n que implique 
concatenar muchas veces para construir paso a paso 
una cadena muy larga?
‚úÖ
Clase String en Java: inmutable
Las instancias de String no se pueden modificar despu√©s de ser creadas.
Cualquier operaci√≥n que parezca ‚Äúmodificar‚Äù un String en realidad crea 
un nuevo objeto.
üîπ
Concatenaci√≥n de cadenas
String s1 = "Hola";
String s2 = " Mundo";
String s3 = s1 + s2;  // Se crea un nuevo String
s1 y s2 no cambian.
s3 es un nuevo objeto String con el resultado.
üîπ
Concatenar muchas veces
Si concatenas muchas veces en un bucle con +, se crean muchos objetos 
temporales, lo que es ineficiente.
‚úÖ
Soluci√≥n: usar StringBuilder o StringBuffer:
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
sb.append("a");
}
String resultado = sb.toString();
StringBuilder es mutable, permite modificar la cadena sin crear nuevos 
objetos.
Es mucho m√°s eficiente para construir cadenas largas paso a paso.
En resumen:
String ‚Üí
 inmutable
Concatenar con + ‚Üí
 crea nuevos objetos
Muchas concatenaciones ‚Üí
 usar StringBuilder para eficiencia.
20. En POO ¬øC√≥mo se comparan objetos de una misma 
clase? ¬øPor su contenido o por su identidad? ¬øQu√© es el 
m√©todo equals en Java? ¬øQu√© hace por defecto? ¬øC√≥mo 
se deben comparar dos cadenas en Java?
‚úÖ
Comparaci√≥n de objetos en POO y Java
1. Por defecto, los objetos se comparan por identidad
Es decir, si apuntan al mismo lugar en memoria, no por su contenido.
Ejemplo:
Punto p1 = new Punto(3, 4);
Punto p2 = new Punto(3, 4);
System.out.println(p1 == p2); // false, son objetos distintos
1. M√©todo equals() en Java
Es un m√©todo de la clase Object que se puede sobrescribir.
Por defecto (Object.equals()): compara identidad, igual que ==.
Si queremos comparar contenido, debemos sobrescribir equals() en 
nuestra clase.
Ejemplo sobrescribiendo equals en Punto:
@Override
public boolean equals(Object obj) {
if (!(obj instanceof Punto)) return false;
Punto otro = (Punto) obj;
return this.getX() == otro.getX() && this.getY() == otro.getY();
}
1. Comparar cadenas (String) en Java
No se debe usar == (compara referencias).
Se debe usar equals() para comparar el contenido:
String s1 = "Hola";
String s2 = new String("Hola");
System.out.println(s1 == s2);        
// false (distintas referencias)
System.out.println(s1.equals(s2));   // true  (mismo contenido)
üîπ
Resumen
Por defecto, los objetos ‚Üí
 comparaci√≥n por identidad.
equals() ‚Üí
 se puede sobrescribir para comparar contenido.
String ‚Üí
 usar equals(), no ==, para comparar el contenido real.
21. ¬øQu√© son las clases "wrapper" en un lenguaje de 
programaci√≥n orientado a objetos? ¬øC√≥mo se hace? ¬øEs 
un proceso autom√°tico? ¬øQu√© ventajas tienen? ¬øTodos 
los lenguajes orientados a objetos tienen tipos 
primitivos y necesitan wrappers?
‚úÖ
Clases "wrapper" en POO
Las clases wrapper son clases que ‚Äúenvuelven‚Äù tipos primitivos (como int, 
double, boolean) para tratarlos como objetos en un lenguaje orientado a 
objetos.
üîπ
C√≥mo se hace en Java
Java tiene clases wrapper para cada tipo primitivo:
Primitivo
int
double
Wrapper
Integer
Double
boolean
char
Ejemplo:
int num = 5;
Boolean
Character
Integer obj = Integer.valueOf(num);  // Convertir int a objeto Integer
int n2 = obj.intValue();             
// Convertir de vuelta a int
Desde Java 5, autoboxing hace esto autom√°ticamente:
Integer obj2 = 10;  // int se convierte autom√°ticamente a Integer
int n3 = obj2;      // Integer se convierte autom√°ticamente a int
üîπ
Ventajas de las clases wrapper
1. Permiten usar tipos primitivos donde se necesitan objetos, por ejemplo en 
colecciones:
ArrayList<Integer> lista = new ArrayList<>();
lista.add(5);  // autoboxing de int a Integer
1. Ofrecen m√©todos √∫tiles: parsear, convertir a cadena, comparar, etc.
2. Facilitan la compatibilidad con APIs que trabajan solo con objetos.
Todos los lenguajes orientados a objetos necesitan wrappers?
üîπ
No necesariamente:
Lenguajes como Java, C# tienen tipos primitivos y necesitan wrappers.
Otros lenguajes como Python, Ruby, JavaScript tratan todos los valores 
como objetos, por lo que no necesitan wrappers expl√≠citos.
En resumen:
Wrappers ‚Üí
 convierten tipos primitivos en objetos, permiten usar m√©todos y 
colecciones, y en Java hay autoboxing que lo hace autom√°tico.
22. ¬øEn POO qu√© es un tipo de dato enumerado? ¬øEn Java, 
un tipo de dato enumerado es una clase? ¬øQu√© ventajas 
tienen en t√©rminos de encapsulaci√≥n los enumerados en 
Java?
‚úÖ
Tipo de dato enumerado en POO
Un tipo de dato enumerado (enum) es un tipo que define un conjunto 
limitado y fijo de valores posibles.
üîπ
Se usa cuando solo se permiten valores espec√≠ficos, por ejemplo: d√≠as de 
la semana, colores, estados.
En Java: un enum es una clase
Cada enumerado en Java es una clase especial que hereda de 
java.lang.Enum.
Cada valor del enum es en realidad un objeto de esa clase.
Ejemplo:
enum Dia {
LUNES, MARTES, MIERCOLES, JUEVES, VIERNES, SABADO, DOMINGO
}
Dia.LUNES es un objeto de la clase Dia.
üîπ
Ventajas de los enumerados en t√©rminos de encapsulaci√≥n
1. Control de valores permitidos ‚Üí
 no se pueden crear valores fuera del 
enum.
2. Protecci√≥n de datos ‚Üí
 los valores son constantes y seguros.
3. M√©todos propios ‚Üí
 un enum puede tener atributos y m√©todos, 
encapsulando comportamiento relacionado con los valores.
Ejemplo con m√©todos en enum:
enum Color {
    ROJO(255,0,0), VERDE(0,255,0), AZUL(0,0,255);
    private int r, g, b;  // encapsulado
    private Color(int r, int g, int b) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    public String rgb() {
        return r + "," + g + "," + b;
    }
}
Los atributos r, g, b est√°n ocultos (private) ‚Üí
 encapsulaci√≥n.
Se accede solo a trav√©s de m√©todos como rgb().
En resumen:
Enum ‚Üí
 tipo de datos con valores limitados.
En Java ‚Üí
 es una clase especial.
Ventajas ‚Üí
 control de valores, seguridad, encapsulaci√≥n y m√©todos 
asociados.
23. Crea un tipo enumerado en Java que se llame Mes, 
con doce posibles instancias y que adem√°s proporcione 
m√©todos para obtener cu√°ntos d√≠as tiene ese mes, el 
ordinal de ese mes en el a√±o (1-12), empleando atributos 
privados y constructores del tipo enumerado.
‚úÖ
 Ejemplo de enum Mes en Java con atributos y m√©todos
public enum Mes {
    ENERO(31), FEBRERO(28), MARZO(31), ABRIL(30),
    MAYO(31), JUNIO(30), JULIO(31), AGOSTO(31),
    SEPTIEMBRE(30), OCTUBRE(31), NOVIEMBRE(30), DICIEMBRE(31);
    // Atributo privado para almacenar los d√≠as del mes
    private final int dias;
    // Constructor privado del enum
    private Mes(int dias) {
        this.dias = dias;
    }
    // M√©todo para obtener los d√≠as del mes
    public int getDias() {
        return dias;
    }
    // M√©todo para obtener el ordinal del mes en el a√±o (1-12)
    public int getOrdinal() {
        return this.ordinal() + 1;  // ordinal() devuelve 0-11
    }
}
üîé
Explicaci√≥n
Cada instancia del enum (ENERO, FEBRERO, etc.) tiene un atributo 
privado dias.
El constructor se llama autom√°ticamente para cada instancia al definir el 
enum.
getDias() permite acceder al n√∫mero de d√≠as de forma controlada.
getOrdinal() devuelve el n√∫mero del mes en el a√±o, sumando 1 al 
ordinal() que empieza en 0.
24. A√±ade a la clase Mes del ejercicio anterior cuatro 
m√©todos para devolver si ese mes tiene algunos d√≠as de 
invierno, primavera, verano u oto√±o, indicando con un 
booleano el hemisferio (norte o sur, par√°metro 
enHemisferioNorte). Es decir: esDePrimavera(boolean 
esHemisferioNorte), esDeVerano(boolean 
esHemisferioNorte), esDeOto√±o(boolean 
esHemisferioNorte), esDeInvierno(boolean 
esHemisferioNorte)
Perfecto. Podemos a√±adir los cuatro m√©todos al enum Mes, usando el 
par√°metro boolean esHemisferioNorte para determinar las estaciones seg√∫n 
el hemisferio.
‚úÖ
C√≥digo actualizado de Mes
public enum Mes {
ENERO(31), FEBRERO(28), MARZO(31), ABRIL(30),
MAYO(31), JUNIO(30), JULIO(31), AGOSTO(31),
SEPTIEMBRE(30), OCTUBRE(31), NOVIEMBRE(30), DICIEMBRE(31);
private final int dias;
private Mes(int dias) {
        this.dias = dias;
    }
    public int getDias() {
        return dias;
    }
    public int getOrdinal() {
        return this.ordinal() + 1;
    }
    // Estaciones seg√∫n hemisferio
    public boolean esDePrimavera(boolean esHemisferioNorte) {
        if (esHemisferioNorte) {
            return this == MARZO || this == ABRIL || this == MAYO;
        } else {
            return this == SEPTIEMBRE || this == OCTUBRE || this == NOVIEMBRE;
        }
    }
    public boolean esDeVerano(boolean esHemisferioNorte) {
        if (esHemisferioNorte) {
            return this == JUNIO || this == JULIO || this == AGOSTO;
        } else {
            return this == DICIEMBRE || this == ENERO || this == FEBRERO;
        }
    }
    public boolean esDeOto√±o(boolean esHemisferioNorte) {
        if (esHemisferioNorte) {
            return this == SEPTIEMBRE || this == OCTUBRE || this == NOVIEMBRE;
        } else {
            return this == MARZO || this == ABRIL || this == MAYO;
        }
    }
    public boolean esDeInvierno(boolean esHemisferioNorte) {
        if (esHemisferioNorte) {
            return this == DICIEMBRE || this == ENERO || this == FEBRERO;
        } else {
            return this == JUNIO || this == JULIO || this == AGOSTO;
        }
    }
}
üîé
 Explicaci√≥n
Cada m√©todo devuelve true si el mes pertenece a la estaci√≥n 
correspondiente en el hemisferio indicado.
esHemisferioNorte = true ‚Üí
 estaciones seg√∫n el hemisferio norte.
esHemisferioNorte = false ‚Üí
 estaciones invertidas para el hemisferio sur.
La interfaz p√∫blica sigue igual: no cambia la forma de acceder a d√≠as ni 
ordinal.
